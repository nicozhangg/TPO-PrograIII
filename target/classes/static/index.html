<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualizador Rutas F1</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.polyline.snakeanim@0.1.0/Leaflet.Polyline.SnakeAnim.js"></script>
</head>
<body>
  <button id="abrir-panel" title="Mostrar men√∫" aria-label="Mostrar men√∫">‚û°Ô∏è</button>

  <div id="panel">
    <div class="panel-header">
      <h4 class="panel-title">üåç Ruta F1</h4>
      <button id="toggle" title="Contraer men√∫" aria-label="Contraer men√∫">‚¨ÖÔ∏è</button>
    </div>

    <label for="algoritmo">Algoritmo:</label>
    <select id="algoritmo" aria-label="Seleccionar algoritmo">
      <option value="nearest">Greedy (TSP)</option>
      <option value="dijkstra">Dijkstra (A ‚Üí B)</option>
      <option value="bfs">BFS (rango km)</option>
      <option value="branch-bound">Branch & Bound TSP</option>
    </select>

    <div id="params">
      <div id="params-dijkstra" class="params-group">
        <input id="origen-dijkstra" placeholder="Origen" aria-label="Origen" />
        <input id="destino-dijkstra" placeholder="Destino" aria-label="Destino" />
      </div>
      
      <div id="params-bfs" class="params-group">
        <input id="inicio-bfs" placeholder="Inicio" aria-label="Inicio" />
        <input id="maxkm-bfs" type="number" placeholder="max_km (default: 3000)" aria-label="Distancia m√°xima" min="0" />
      </div>
      
      <div id="params-branch-bound" class="params-group">
        <input id="origen-branch-bound" placeholder="Origen" aria-label="Origen" />
      </div>
    </div>

    <button id="ejecutar">Ejecutar</button>
  </div>

  <div id="map" role="application" aria-label="Mapa de circuitos F1"></div>

  <script>
    // ==================== CONFIGURACI√ìN ====================
    const CONFIG = {
      map: {
        center: [20, 0],
        zoom: 2,
        tileUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        attribution: '¬© OpenStreetMap contributors'
      },
      colores: {
        nearest: 'red',
        dijkstra: 'blue',
        bfs: 'green',
        'branch-bound': 'purple'
      },
      estilos: {
        ruta: {
          weight: 4,
          opacity: 0.8
        },
        mst: {
          color: 'gray',
          weight: 2,
          opacity: 0.4,
          dashArray: '5, 5'
        }
      },
      defaultMaxKm: 3000
    };

    // ==================== INICIALIZACI√ìN ====================
    const map = L.map('map').setView(CONFIG.map.center, CONFIG.map.zoom);
    L.tileLayer(CONFIG.map.tileUrl, {
      attribution: CONFIG.map.attribution
    }).addTo(map);

    const elementos = {
      panel: document.getElementById('panel'),
      toggle: document.getElementById('toggle'),
      abrirBtn: document.getElementById('abrir-panel'),
      algoritmo: document.getElementById('algoritmo'),
      ejecutar: document.getElementById('ejecutar'),
      params: {
        dijkstra: document.getElementById('params-dijkstra'),
        bfs: document.getElementById('params-bfs'),
        'branch-bound': document.getElementById('params-branch-bound')
      },
      inputs: {
        origenDijkstra: document.getElementById('origen-dijkstra'),
        destinoDijkstra: document.getElementById('destino-dijkstra'),
        inicioBfs: document.getElementById('inicio-bfs'),
        maxkmBfs: document.getElementById('maxkm-bfs'),
        origenBranchBound: document.getElementById('origen-branch-bound')
      }
    };

    let oculto = false;
    const markers = [];
    const polylines = [];
    let popupActual = null;

    // ==================== UTILIDADES ====================
    const limpiarMapa = () => {
      // Cerrar popups abiertos
      if (popupActual) {
        map.closePopup(popupActual);
        popupActual = null;
      }
      map.closePopup();
      
      // Remover todos los marcadores
      markers.forEach(marker => {
        if (marker && map.hasLayer(marker)) {
          map.removeLayer(marker);
        }
      });
      markers.length = 0;
      
      // Remover todas las polil√≠neas
      polylines.forEach(polyline => {
        if (polyline && map.hasLayer(polyline)) {
          map.removeLayer(polyline);
        }
      });
      polylines.length = 0;
      
      // Remover cualquier otra capa que no sea la base (tiles)
      map.eachLayer(layer => {
        if (layer instanceof L.Marker || layer instanceof L.Polyline || layer instanceof L.Popup) {
          map.removeLayer(layer);
        }
      });
    };

    const mostrarPopup = (coords, contenido) => {
      // Cerrar popup anterior si existe
      if (popupActual) {
        map.closePopup(popupActual);
      }
      
      popupActual = L.popup()
        .setLatLng(coords)
        .setContent(contenido)
        .openOn(map);
    };

    const crearMarcador = (coords, nombre, index) => {
      const marker = L.marker(coords)
        .addTo(map)
        .bindPopup(`<b>${index + 1}. ${nombre}</b>`);
      markers.push(marker);
      return marker;
    };

    const crearPolilinea = (coords, color, estilo = {}) => {
      const polyline = L.polyline(coords, {
        color: color || 'red',
        ...CONFIG.estilos.ruta,
        ...estilo
      }).addTo(map);
      
      // Intentar animar solo si la librer√≠a est√° disponible y no es l√≠nea punteada
      if (!estilo.dashArray && typeof polyline.snakeIn === 'function') {
        try {
          polyline.snakeIn();
        } catch (e) {
          console.warn('No se pudo animar la l√≠nea:', e);
        }
      }
      
      polylines.push(polyline);
      return polyline;
    };

    // ==================== UI ====================
    const togglePanel = () => {
      oculto = !oculto;
      elementos.panel.classList.toggle('oculto', oculto);
      elementos.abrirBtn.style.display = oculto ? 'block' : 'none';
    };

    const actualizarCampos = () => {
      const algoritmo = elementos.algoritmo.value;
      
      Object.values(elementos.params).forEach(group => {
        group.classList.remove('active');
      });

      if (algoritmo === 'dijkstra') {
        elementos.params.dijkstra.classList.add('active');
      } else if (algoritmo === 'bfs') {
        elementos.params.bfs.classList.add('active');
      } else if (algoritmo === 'branch-bound') {
        elementos.params['branch-bound'].classList.add('active');
      }
    };

    elementos.toggle.addEventListener('click', togglePanel);
    elementos.abrirBtn.addEventListener('click', togglePanel);
    elementos.algoritmo.addEventListener('change', actualizarCampos);
    actualizarCampos();

    // ==================== VISUALIZACI√ìN ====================
    const visualizarRuta = (puntosRuta, color, algoritmo, data) => {
      if (!puntosRuta || puntosRuta.length === 0) {
        alert('No se encontraron puntos para mostrar');
        return;
      }

      const coords = puntosRuta.map(p => [p.lat, p.lon]);

      // Crear marcadores
      puntosRuta.forEach((p, i) => {
        crearMarcador([p.lat, p.lon], p.nombre, i);
      });

      // Crear polil√≠nea
      const linea = crearPolilinea(coords, color);
      map.fitBounds(linea.getBounds());

      // Popup con informaci√≥n
      let texto = `<b>${data.algoritmo}</b>`;
      if (data.km_totales) texto += `<br>Distancia: ${data.km_totales} km`;
      if (data.max_km) texto += `<br>max_km: ${data.max_km}`;
      mostrarPopup(coords[0], texto);
    };


    // ==================== API ====================
    const construirUrl = (algoritmo) => {
      let url = `/api/algoritmos/${algoritmo}`;
      const params = new URLSearchParams();

      if (algoritmo === 'dijkstra') {
        const origen = elementos.inputs.origenDijkstra.value.trim();
        const destino = elementos.inputs.destinoDijkstra.value.trim();
        
        if (!origen || !destino) {
          alert('Debes ingresar origen y destino');
          return null;
        }
        
        params.append('origen', origen);
        params.append('destino', destino);
      } else if (algoritmo === 'bfs') {
        const inicio = elementos.inputs.inicioBfs.value.trim();
        const maxkm = elementos.inputs.maxkmBfs.value || CONFIG.defaultMaxKm;
        
        if (!inicio) {
          alert('Debes ingresar circuito de inicio');
          return null;
        }
        
        params.append('inicio', inicio);
        params.append('max_km', maxkm);
      } else if (algoritmo === 'branch-bound') {
        const origen = elementos.inputs.origenBranchBound.value.trim();
        if (origen) {
          params.append('origen', origen);
        }
      }

      return params.toString() ? `${url}?${params.toString()}` : url;
    };

    const obtenerPuntosRuta = (data, algoritmo) => {
      if (algoritmo === 'nearest' || algoritmo === 'dijkstra' || algoritmo === 'branch-bound') {
        return data.puntos_ruta;
      } else if (algoritmo === 'bfs') {
        return data.puntos_orden;
      }
      return null;
    };

    // ==================== EJECUTAR ====================
    elementos.ejecutar.addEventListener('click', async () => {
      // Limpiar mapa ANTES de ejecutar cualquier algoritmo
      limpiarMapa();
      
      try {
        const algoritmo = elementos.algoritmo.value;
        const url = construirUrl(algoritmo);
        
        if (!url) {
          // Si no hay URL v√°lida, el mapa ya est√° limpio
          return;
        }

        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Error ${res.status}: ${res.statusText}`);
        }

        const data = await res.json();

        // Limpiar de nuevo por si acaso antes de mostrar la nueva ruta
        limpiarMapa();

        if (algoritmo === 'branch-bound' || algoritmo === 'nearest' || algoritmo === 'dijkstra' || algoritmo === 'bfs') {
          const puntosRuta = obtenerPuntosRuta(data, algoritmo);
          const color = CONFIG.colores[algoritmo] || 'red';
          visualizarRuta(puntosRuta, color, algoritmo, data);
        }
      } catch (error) {
        console.error('Error:', error);
        alert(`Error al ejecutar el algoritmo: ${error.message}`);
        // Asegurar que el mapa est√© limpio incluso si hay error
        limpiarMapa();
      }
    });
  </script>
</body>
</html>
